数组是一种最简单的线性数据接口，其用一组连续的内存空间，来存储一组具有相同类型的数据。以高效查询著称，相对来说：插入删除低效

数组根据下标的随机访问时间复杂度是O(1)

    插入低效，比如一个n长的数据，要在k位置插入一个元素，那么，k-n这些元素都要往后移一个位置，那么来分析一些数组的插入时间复杂度：
假如在尾部插入元素，就不需要移动数据，时间复杂度就是O(1),如果是在首位插入元素，那么所有的其它元素都要往后移动一个位置，时间复杂
度就是O(n)，最坏时间复杂度是O(n)。因为每个位置插入元素概率是一样的，所以平均时间复杂度就是：(1)+2+。。。+n)/n=O(n)。

    既然插入这么低效，有没有好的优化方法呢？答案是有的，如果数组是有序的，那么就只能按照上述方法插入到k处，然后k-n的元素后移一个位置
但是如果数组是没有顺序的，有个高效的方法就是，把新插入的元素放到k处，然后把k处的元素放到尾部，这么一来，时间复杂度就是O(1)了

    删除和插入类似，为了保证空间连续性，也是需要涉及元素移动，平均复杂度也是O(n)，删除也有优化方法，比如数组有a,b,c,d,e,f几个元素
现在要删除，a,b，删除时候，可以先不移动位置，只是标记a,b需要删除，当数组内存不够用了，在进行删除，其实【垃圾回收算法标记清除】就是这个算法


再来看一个问题：为什么数据元素下标要从0开始，而不是从1？
    假设现在有一个int类型的数据a[]，首位置的内存地址假如是base_address = 1000，a[i]_address = base_address + i * data_type_size
又因为存储的是int，这里data_type_size就是4个字节。再回到问题，数组元素的下标，其实就是偏移，用a标示数组，那么a[0]就表示偏移为 0 的位置，
也就是首地址，a[k]标示偏移k的位置，那么a[k]_address = base_address + k * data_type_size，如果从 1 开始呢，k位置的元素寻址就变成了：
a[k]_address = base_address + （k-1） * data_type_size，多了一次减法计算，对于CPU来说，就是多了一个CPU指令